<!doctype html>
<html lang="zh"><head>
<title>RestTemplate与OpenFeign - Honesty Wiki</title>
<meta charset="UTF-8">
<meta name="keywords" content="Honesty 知识库,Honesty Wiki, Honesty blog,hehouhui 知识库,hehouhui Wiki, hehouhui blog">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">

<link rel="shortcut icon" href="https://www.make.com/en/favicon.ico" type="image/x-icon" />
<meta name="description" content="RestTemplate在SpringCloud体系中，我们知道服务之间的调用是通过http协议进行调用的。而注册中心的主要目的就是维护这些服务的服务列表。我们知道，在Spring中，提供了RestTemplate。RestTemplate是Spring提供的用于访问 Rest 服务的客户端。而在SpringCloud中也是使用此服务进行服务调用的。 同时在微服务中，一般上服务都不会进行单点部署的">
<meta property="og:type" content="article">
<meta property="og:title" content="RestTemplate与OpenFeign">
<meta property="og:url" content="https://docs.hehouhui.cn/archives/20.html">
<meta property="og:site_name" content="Honesty Wiki">
<meta property="og:description" content="RestTemplate在SpringCloud体系中，我们知道服务之间的调用是通过http协议进行调用的。而注册中心的主要目的就是维护这些服务的服务列表。我们知道，在Spring中，提供了RestTemplate。RestTemplate是Spring提供的用于访问 Rest 服务的客户端。而在SpringCloud中也是使用此服务进行服务调用的。 同时在微服务中，一般上服务都不会进行单点部署的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/60217159.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/60831825.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/44882339.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/49529849.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/19525388.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/9663891.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/91101426.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/50274746.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/94233042.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/67366013.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/74317604.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/2558852.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/15565028.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/65199797.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/70647514.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/86401854.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/40970081.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/20652450.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/75877117.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/55952682.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/33505933.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/6039671.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/75808703.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/63370995.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-20/84887976.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-21/73056978.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-21/82979252.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-21/59541189.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-21/13645724.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-21/95656166.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-21/6181280.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-21/39759685.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-21/99970618.jpg">
<meta property="og:image" content="http://qiniu.xds123.cn/18-9-21/10151632.jpg">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191106161350811.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191107162815756.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191107163802485.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191108111558612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwNjMyMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191108143112594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwNjMyMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20191108145133749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwNjMyMg==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/201911081504477.png">
<meta property="article:published_time" content="2021-08-27T00:00:00.000Z">
<meta property="article:modified_time" content="2023-10-08T14:42:00.000Z">
<meta property="article:author" content="Honesty">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="微服务">
<meta property="article:tag" content="分布式">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.xds123.cn/18-9-20/60217159.jpg">

<link rel="stylesheet" href="/lib/fancybox/fancybox.css">
<link rel="stylesheet" href="/lib/mdui_043tiny/mdui.css">


<link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1699545727614">

<link rel="stylesheet" href="/css/style.css?v=1699545727614">




    
        <link rel="stylesheet" href="/custom.css?v=1699545727614">
    



<script src="/lib/mdui_043tiny/mdui.js" async></script>
<script src="/lib/fancybox/fancybox.umd.js" async></script>
<script src="/lib/lax.min.js" async></script>


<script async src="/js/app.js?v=1699545727614"></script>

 

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-248JM4ZRPJ"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag("js", new Date());

  gtag("config", "G-248JM4ZRPJ");
</script>

<meta name="generator" content="Hexo 6.3.0"></head><body class="nexmoe mdui-drawer-body-left"><div id="nexmoe-background"><div class="nexmoe-bg" style="background-image: url(https://blog-file.hehouhui.cn/202305111934350.jpeg)"></div><div class="mdui-appbar mdui-shadow-0"><div class="mdui-toolbar"><a class="mdui-btn mdui-btn-icon mdui-ripple" mdui-drawer="{target: &#039;#drawer&#039;, swipe: true}" title="menu"><i class="mdui-icon nexmoefont icon-menu"></i></a><div class="mdui-toolbar-spacer"></div><a class="mdui-btn mdui-btn-icon" href="/" title="Honesty"><img src="https://cdn.jsdelivr.net/gh/listener-He/images@default/202309111525908.jpeg" alt="Honesty"></a></div></div></div><div id="nexmoe-header"><div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Honesty">
            <img src="https://cdn.jsdelivr.net/gh/listener-He/images@default/202309111525908.jpeg" alt="Honesty" alt="Honesty">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>33</div>
        <div><span>标签</span>33</div>
        <div><span>分类</span>4</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/history.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/friend.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/donate.html" title="给我赞助">
            <i class="mdui-list-item-icon nexmoefont icon-coffee"></i>
            <div class="mdui-list-item-content">
                给我赞助
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about.html" title="关于博主">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博主
            </div>
        </a>
        
    </div>
    
    
        
        <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:hehouhui.cn" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
            </form>
         
    </div>
</div>




    
        
        <div class="nexmoe-widget-wrap">
	<div class="nexmoe-widget nexmoe-social">
		<a
			class="mdui-ripple"
			href="https://space.bilibili.com/442038841"
			target="_blank"
			mdui-tooltip="{content: '哔哩哔哩'}"
			style="
				color: rgb(231, 106, 141);
				background-color: rgba(231, 106, 141, .1);
			"
		>
			<i
				class="nexmoefont icon-bilibili"
			></i> </a
		><a
			class="mdui-ripple"
			href="https://github.com/listener-He"
			target="_blank"
			mdui-tooltip="{content: 'GitHub'}"
			style="
				color: rgb(25, 23, 23);
				background-color: rgba(25, 23, 23, .1);
			"
		>
			<i
				class="nexmoefont icon-github"
			></i> </a
		><a
			class="mdui-ripple"
			href="https://www.zhihu.com/people/wen-xin-92-2-57"
			target="_blank"
			mdui-tooltip="{content: '知乎'}"
			style="
				color: rgb(30, 136, 229);
				background-color: rgba(30, 136, 229, .1);
			"
		>
			<i
				class="nexmoefont icon-zhihu"
			></i> </a
		><a
			class="mdui-ripple"
			href="https://twitter.com/Honesty861024"
			target="_blank"
			mdui-tooltip="{content: 'Twitter'}"
			style="
				color: rgb(59, 151, 239);
				background-color: rgba(59, 151, 239, .1);
			"
		>
			<i
				class="nexmoefont icon-twitter"
			></i> </a
		><a
			class="mdui-ripple"
			href="https://docs.hehouhui.cn/atom.xml"
			target="_blank"
			mdui-tooltip="{content: 'RSS'}"
			style="
				color: rgb(247, 132, 34);
				background-color: rgba(247, 132, 34, .1);
			"
		>
			<i
				class="nexmoefont icon-rss"
			></i> </a
		>
	</div>
</div>

    
        
        
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/创作分享/">创作分享</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/学习思考/">学习思考</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/技术分享/">技术分享</a>
          <span class="category-list-count">27</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/碎片杂文/">碎片杂文</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


    
        
        
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/BUG/" style="font-size: 10px;">BUG</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Jvm/" style="font-size: 10px;">Jvm</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/Redis/" style="font-size: 15.71px;">Redis</a> <a href="/tags/SAAS/" style="font-size: 10px;">SAAS</a> <a href="/tags/Spring/" style="font-size: 18.57px;">Spring</a> <a href="/tags/WebFlux/" style="font-size: 10px;">WebFlux</a> <a href="/tags/chatgpt/" style="font-size: 10px;">chatgpt</a> <a href="/tags/hutool/" style="font-size: 10px;">hutool</a> <a href="/tags/keycloak/" style="font-size: 12.86px;">keycloak</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/notion/" style="font-size: 10px;">notion</a> <a href="/tags/oauth/" style="font-size: 12.86px;">oauth</a> <a href="/tags/%E5%81%A5%E5%BA%B7/" style="font-size: 10px;">健康</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 14.29px;">分布式</a> <a href="/tags/%E5%92%96%E5%95%A1/" style="font-size: 10px;">咖啡</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/" style="font-size: 10px;">响应式</a> <a href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" style="font-size: 11.43px;">图像处理</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 11.43px;">多线程</a> <a href="/tags/%E5%AD%A6%E4%B9%A0/" style="font-size: 11.43px;">学习</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 12.86px;">建站</a> <a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 12.86px;">开发</a> <a href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/" style="font-size: 12.86px;">异步编程</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 17.14px;">微服务</a> <a href="/tags/%E6%80%9D%E8%80%83/" style="font-size: 12.86px;">思考</a> <a href="/tags/%E6%8A%80%E6%9C%AF%E6%B5%81/" style="font-size: 10px;">技术流</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%95%B4%E6%B4%BB/" style="font-size: 10px;">整活</a> <a href="/tags/%E6%96%87%E5%AD%97/" style="font-size: 12.86px;">文字</a> <a href="/tags/%E7%89%A9%E8%81%94%E7%BD%91/" style="font-size: 10px;">物联网</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 11.43px;">缓存</a>
    </div>
    
      <script>
        var maxTagcloud = parseInt(17);
        var tags_length = parseInt(33);
        var tags_arr = [];
        for(var i = 0; i < tags_length; i++){
          tags_arr.push(i);
        }
        tags_arr.sort(function (l, r) {
          return Math.random() > 0.5 ? -1 : 1;
        });
        tags_arr = tags_arr.slice(0, maxTagcloud < tags_length ? tags_length - maxTagcloud : 0);
        for(var tag_i = 0; tag_i < tags_arr.length; tag_i++){
          document.getElementById("randomtagcloud").children[tags_arr[tag_i]].style.display = 'none';
        }
      </script>
    
  </div>

    
        
        
        
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/history/2023/">2023</a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/history/2022/">2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/history/2021/">2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/history/2020/">2020</a><span class="archive-list-count">7</span></li></ul>
    </div>
  </div>



    
        
        
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">最新文章</h3>
    <div class="nexmoe-widget">
      <ul>
        
          <li>
            <a href="/archives/java-sync-introduce-1104.html">Java异步编程方式介绍</a>
          </li>
        
          <li>
            <a href="/archives/spring-boot-tenant-202309.html">Spring Boot 实现多租户架构：支持应用多租户部署和管理</a>
          </li>
        
          <li>
            <a href="/archives/springcloud-data-202309.html">微服务之间的数据依赖问题，该如何解决？</a>
          </li>
        
          <li>
            <a href="/archives/redis-key-202309.html">Redis 热key是什么问题，如何导致的？有什么解决方案？</a>
          </li>
        
          <li>
            <a href="/archives/spring-restclient-2023.html">HttpClient? RestTemplate？WebClient? 不~是 RestClient</a>
          </li>
        
      </ul>
    </div>
  </div>

    
        
   
    <div class="nexmoe-copyright">
        &copy; 2023 Honesty
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <br><a target="_blank" href="https://beian.miit.gov.cn/">湘ICP备20014902号</a>
<br><a target="_blank" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">

    </div>
</div><!-- .nexmoe-drawer --></div><div id="nexmoe-content"><div class="nexmoe-primary"><div class="nexmoe-post">
  <article>
    
        <div class="nexmoe-post-cover absolute" style="padding-top: NaN%;"> 
            <img src="https://www.notion.so/images/page-cover/webb2.jpg" alt="RestTemplate与OpenFeign" loading="lazy">
            <h1>RestTemplate与OpenFeign</h1>
        </div>
    
    
    <div class="nexmoe-post-meta">
    <div class="nexmoe-rainbow">
        <a class="nexmoefont icon-calendar-fill">2021年08月27日</a>
        
            <a class="nexmoefont icon-appstore-fill -link" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/">技术分享</a>
        
        
    </div>
    
    
    
    
    
</div>

    <h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><p>在<code>SpringCloud</code>体系中，我们知道服务之间的调用是通过<code>http</code>协议进行调用的。而注册中心的主要目的就是维护这些服务的服务列表。我们知道，在<code>Spring</code>中，提供了<code>RestTemplate</code>。<code>RestTemplate</code>是<code>Spring</code>提供的用于访问 Rest 服务的客户端。而在<code>SpringCloud</code>中也是使用此服务进行服务调用的。</p>
<p>同时在微服务中，一般上服务都不会进行单点部署的，都会至少部署 2 台及以上的。现在我们有了注册中心进行服务列表的维护，就需要一个客户端负载均衡来进行动态服务的调用。</p>
<p>所以开始示例前，我们先来大致了解下关于<code>负载均衡</code>和<code>RestTemplate</code>的相关知识点。其实后面实例的<code>Ribbon</code>和<code>Feign</code>最后的调用都是基于<code>RestTemplate</code>的。使用比较简单~</p>
<h3 id="何为负载均衡"><a href="#何为负载均衡" class="headerlink" title="何为负载均衡"></a>何为负载均衡</h3><blockquote>
<p>负载均衡(Load Balance)是分布式系统架构设计中必须考虑的因素之一，它通常是指，将请求&#x2F;数据<strong>【均匀】分摊</strong>到多个操作单元上执行，负载均衡的关键在于【均匀】。</p>
</blockquote>
<h3 id="实现的方式"><a href="#实现的方式" class="headerlink" title="实现的方式"></a>实现的方式</h3><p>实现负载均衡的方式有很多种，这里简单介绍下几种方式，并未过多深入。</p>
<p><strong>注意：以下部分内容转至</strong><a target="_blank" rel="noopener" href="https://blog.csdn.net/mengdonghui123456/article/details/53981976"><strong>几种负载均衡技术的实现</strong></a><strong>。</strong></p>
<p>1.HTTP 重定向负载均衡</p>
<blockquote>
<p>根据用户的 http 请求计算出一个真实的 web 服务器地址，并将该 web 服务器地址写入 http 重定向响应中返回给浏览器，由浏览器重新进行访问</p>
</blockquote>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/60217159.jpg" alt="60217159.jpg" data-caption="60217159.jpg" loading="lazy"></p>
<p><strong>优缺点：实现起来很简单，而缺点也显而易见了：请求两次才能完成一次访问；性能差;重定向服务器会成为瓶颈</strong></p>
<p>2.DNS 域名解析负载均衡</p>
<blockquote>
<p>在 DNS 服务器上配置多个域名对应 IP 的记录。例如一个域名<a target="_blank" rel="noopener" href="http://www.baidu.com对应一组web服务器ip地址,域名解析时经过dns服务器的算法将一个域名请求分配到合适的真实服务器上./">www.baidu.com对应一组web服务器IP地址，域名解析时经过DNS服务器的算法将一个域名请求分配到合适的真实服务器上。</a></p>
</blockquote>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/60831825.jpg" alt="60831825.jpg" data-caption="60831825.jpg" loading="lazy"></p>
<p><strong>优缺点：加快访问速度,改善性能。同时由于 DNS 解析是多级解析，每一级 DNS 都可能化缓存记录 A，当某一服务器下线后，该服务器对应的 DNS 记录 A 可能仍然存在，导致分配到该服务器的用户访问失败，而且 DNS 负载均衡采用的是简单的轮询算法，不能区分服务器之间的差异，不能反映服务器当前运行状态。</strong></p>
<p>3.反向代理负载均衡</p>
<blockquote>
<p>反向代理处于 web 服务器这边，反向代理服务器提供负载均衡的功能，同时管理一组 web 服务器，它根据负载均衡算法将请求的浏览器访问转发到不同的 web 服务器处理，处理结果经过反向服务器返回给浏览器。</p>
</blockquote>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/44882339.jpg" alt="44882339.jpg" data-caption="44882339.jpg" loading="lazy"></p>
<p><strong>优缺点：实现简单，可利用反向代理缓存资源(这是最常用的了)及改善网站性能。同时因为是所有请求和响应的中转站，所以反向代理服务器可能成为瓶颈。</strong></p>
<p><strong>以上仅仅是部分实现方式，还有比如**</strong><code>IP负载均衡</code>*<strong>*、**</strong><code>数据链路层负载均衡</code>*<strong>*等等，这些可能涉及到相关网络方面的知识点了，不是很了解，大家有兴趣可以自行搜索下吧。</strong></p>
<h3 id="客户端和服务端的负载均衡"><a href="#客户端和服务端的负载均衡" class="headerlink" title="客户端和服务端的负载均衡"></a>客户端和服务端的负载均衡</h3><p>实现负载均衡也又区分客户端和服务端之分，<code>Ribbon</code>就是基于客户端的负载均衡。<br>客户端负载均衡：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/49529849.jpg" alt="49529849.jpg" data-caption="49529849.jpg" loading="lazy"></p>
<p>服务端负载均衡：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/19525388.jpg" alt="19525388.jpg" data-caption="19525388.jpg" loading="lazy"></p>
<p>服务端实现负载均衡方式有很多，比如：<code>硬件F5</code>、<code>Nginx</code>、<code>HA Proxy</code>等等，这些应该实施相关人员应该比较熟悉了，本人可能也就对<code>Nginx</code>了解下，⊙﹏⊙‖∣</p>
<h3 id="RestTemplate-简单介绍"><a href="#RestTemplate-简单介绍" class="headerlink" title="RestTemplate 简单介绍"></a>RestTemplate 简单介绍</h3><blockquote>
<p>RestTemplate 是 Spring 提供的用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程 Http 服务的方法，能够大大提高客户端的编写效率。</p>
</blockquote>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/9663891.jpg" alt="9663891.jpg" data-caption="9663891.jpg" loading="lazy"></p>
<p>简单来说，<code>RestTemplate</code>采用了<code>模版设计</code>的设计模式，将过程中与特定实现相关的部分委托给接口,而这个接口的不同实现定义了接口的不同行为,所以可以很容易的使用不同的第三方 http 服务，如<code>okHttp</code>、<code>httpclient</code>等。</p>
<p><code>RestTemplate</code>定义了很多的与 REST 资源交互，这里简单介绍下一些常用的请求方式的使用。</p>
<h3 id="exchange"><a href="#exchange" class="headerlink" title="exchange"></a>exchange</h3><p>在 URL 上执行特定的 HTTP 方法，返回包含对象的<code>ResponseEntity</code>。其他的如<code>GET</code>、<code>POST</code>等方法底层都是基于此方法的。</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/91101426.jpg" alt="91101426.jpg" data-caption="91101426.jpg" loading="lazy"></p>
<p>如：</p>
<ul>
<li>get 请求</li>
</ul>
<pre class="language-text" data-language="text"><code class="language-text">RequestEntity requestEntity = RequestEntity.get(new URI(uri)).build();
ResponseEntity&lt;User> responseEntity2 = this.restTemplate.exchange(requestEntity, User.class);
</code></pre>

<ul>
<li>post 请求</li>
</ul>
<pre class="language-text" data-language="text"><code class="language-text">RequestEntity&lt;User> requestEntity = RequestEntity.post(new URI(uri)).body(user);
ResponseEntity&lt;User> responseEntity2 = this.restTemplate.exchange(requestEntity, User.class);
</code></pre>

<h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><blockquote>
<p>get 请求可以分为两类：getForEntity() 和 getForObject().</p>
</blockquote>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/50274746.jpg" alt="50274746.jpg" data-caption="50274746.jpg" loading="lazy"></p>
<pre class="language-text" data-language="text"><code class="language-text">// 1-getForObject()
User user1 = this.restTemplate.getForObject(uri, User.class);

// 2-getForEntity()
ResponseEntity&lt;User> responseEntity1 = this.restTemplate.getForEntity(uri, User.class);
HttpStatus statusCode = responseEntity1.getStatusCode();
HttpHeaders header = responseEntity1.getHeaders();
User user2 = responseEntity1.getBody();
</code></pre>

<p>其他的方法都大同小异了，可以根据实际的业务需求进行调用。</p>
<h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/94233042.jpg" alt="94233042.jpg" data-caption="94233042.jpg" loading="lazy"></p>
<p>简单示例：</p>
<pre class="language-text" data-language="text"><code class="language-text">// 1-postForObject()
User user1 = this.restTemplate.postForObject(uri, user, User.class);

// 2-postForEntity()
ResponseEntity&lt;User> responseEntity1 = this.restTemplate.postForEntity(uri, user, User.class);
</code></pre>

<p><strong>关于**</strong><code>postForLocation()</code>*<strong>*，用的比较少，作用是返回新创建资源的 URI，前面介绍的两者是返回资源本身，也就是结果集了。</strong></p>
<p>关于其他的请求类型相关用法，这里就不详细阐述了，都是类似的。可以查看下此文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/itguangit/article/details/78825505">详解 RestTemplate 操作</a>，讲的蛮详细了。</p>
<ul>
<li>*特别说明：系列教程为了方便，github 上分别创建了一个单体的<code>Eureka</code>注册中心和高可用的<code>Eureka</code>注册中心，无特殊说明，都是使用单体的<code>Eureka</code>注册中心进行服务注册与发现的，工程名为：<code>spring-cloud-eureka-server</code>，端口号为：1000。服务提供方工程名为：<code>spring-cloud-eureka-client</code>,应用名称为：<code>eureka-client</code>,端口号为：2000，提供了一个接口：<a target="_blank" rel="noopener" href="http://127.0.0.1:2000/hello**">http://127.0.0.1:2000/hello**</a></li>
</ul>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/67366013.jpg" alt="67366013.jpg" data-caption="67366013.jpg" loading="lazy"></p>
<p>spring-cloud-eureka-server 示例：<a target="_blank" rel="noopener" href="https://github.com/xie19900123/spring-cloud-learning/tree/master/spring-cloud-eureka-server">spring-cloud-eureka-server</a></p>
<p>spring-cloud-eureka-client 示例：<a target="_blank" rel="noopener" href="https://github.com/xie19900123/spring-cloud-learning/tree/master/spring-cloud-eureka-client">spring-cloud-eureka-client</a></p>
<h2 id="LoadBalancerClient-实例"><a href="#LoadBalancerClient-实例" class="headerlink" title="LoadBalancerClient 实例"></a>LoadBalancerClient 实例</h2><p>此类是实现客户端负载均衡的关键。本身它是个接口类，位于<code>spring-cloud-commons</code>包下，此包包含了大量的服务治理相关的抽象接口，比如已经介绍过的<code>DiscoveryClient</code>、<code>ServiceRegistry</code>以及<code>LoadBalancerClient实例</code>等等。</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/74317604.jpg" alt="74317604.jpg" data-caption="74317604.jpg" loading="lazy"></p>
<p>首先，我们使用最原生的方式去获取调用服务接口。</p>
<p><strong>创建个工程:**</strong><code>spring-cloud-eureka-consumer</code>**</p>
<p>0.引入 pom 文件依赖。</p>
<pre class="language-text" data-language="text"><code class="language-text">&lt;!-- 客户端依赖 -->
    &lt;dependency>
        &lt;groupId>org.springframework.cloud&lt;/groupId>
        &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId>
    &lt;/dependency>
    &lt;dependency>
        &lt;groupId>org.springframework.boot&lt;/groupId>
        &lt;artifactId>spring-boot-starter-web&lt;/artifactId>
    &lt;/dependency>
</code></pre>

<p>1.配置文件添加相关注册中心等信息。</p>
<pre class="language-text" data-language="text"><code class="language-text">## 服务名称
spring.application.name=eureka-consumer
## 端口号
server.port=8008

#指定注册中心地址
eureka.client.service-url.defaultZone=http://127.0.0.1:1000/eureka
# 启用ip配置 这样在注册中心列表中看见的是以ip+端口呈现的
eureka.instance.prefer-ip-address=true
# 实例名称  最后呈现地址：ip:2000
eureka.instance.instance-id=$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;
</code></pre>

<p>2.编写启动类，加入<code>@EnableDiscoveryClient</code>,申明为一个客户端应用,同时申明一个<code>RestTemplate</code>，最后是使用<code>RestTemplate</code>来完成 rest 服务调用的。</p>
<pre class="language-text" data-language="text"><code class="language-text">@SpringBootApplication
@EnableDiscoveryClient
@Slf4j
public class EurekaConsumerApplication &#123;

    public static void main(String[] args) throws Exception &#123;
        SpringApplication.run(EurekaConsumerApplication.class, args);
        log.info("spring-cloud-eureka-consumer启动!");
    &#125;

    @Bean
    public RestTemplate restTemplate() &#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>

<p>3.编写一个调用类，调用<code>spring-cloud-eureka-client</code>服务提供者提供的服务。</p>
<pre class="language-text" data-language="text"><code class="language-text">/**
 * 访问客户端示例
 * @author Hehui
 *
 */
@RestController
@Slf4j
public class DemoController &#123;

    @Autowired
    LoadBalancerClient loadBalancerClient;

    @Autowired
    RestTemplate restTemplate;

    @GetMapping("/hello")
    public String hello(String name) &#123;
        ServiceInstance serviceInstance = loadBalancerClient.choose("eureka-client");
        String url = "http://" + serviceInstance.getHost() + ":" + serviceInstance.getPort() + "/hello?name=" + name;
        log.info("url地址为：&#123;&#125;", url);
        return restTemplate.getForObject(url, String.class);
    &#125;
&#125;
</code></pre>

<p>4.启动应用，访问：<a target="_blank" rel="noopener" href="http://127.0.0.1:8008/hell0?name=oKong">http://127.0.0.1:8008/hell0?name=oKong</a> ，可以看见控制台输出了利用<code>LoadBalancerClient</code>的<code>choose</code>方法，获取到了对应<code>eureka-client</code>服务 ID 的服务地址。</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/2558852.jpg" alt="2558852.jpg" data-caption="2558852.jpg" loading="lazy"></p>
<p>最后通过范围对应的 http 地址进行服务请求：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/15565028.jpg" alt="15565028.jpg" data-caption="15565028.jpg" loading="lazy"></p>
<p>最后浏览器上可以看见，进行了正确的访问了：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/65199797.jpg" alt="65199797.jpg" data-caption="65199797.jpg" loading="lazy"></p>
<p>此时，切换到服务提供者</p>
<pre class="language-text" data-language="text"><code class="language-text">spring-cloud-eureka-client</code></pre>

<p>控制台，可以看见日志输出：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/70647514.jpg" alt="70647514.jpg" data-caption="70647514.jpg" loading="lazy"></p>
<p>此时我们已经调用成功了，通过<code>LoadBalancerClient</code>获取到了服务提供者实际服务地址，最后进行调用。</p>
<p>大家可以创建多个的<code>spring-cloud-eureka-client</code>服务提供者，再去调用下，可以看见会调用不同的服务地址的。</p>
<h2 id="客户端负载均衡-Ribbon-实例"><a href="#客户端负载均衡-Ribbon-实例" class="headerlink" title="客户端负载均衡 Ribbon 实例"></a>客户端负载均衡 Ribbon 实例</h2><blockquote>
<p>Spring Cloud Ribbon 是一个基于 Http 和 TCP 的客服端负载均衡工具，它是基于 Netflix Ribbon 实现的。与 Eureka 配合使用时，Ribbon 可自动从 Eureka Server (注册中心)获取服务提供者地址列表，并基于负载均衡算法，通过在客户端中配置 ribbonServerList 来设置服务端列表去轮询访问以达到均衡负载的作用。</p>
</blockquote>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/86401854.jpg" alt="86401854.jpg" data-caption="86401854.jpg" loading="lazy"></p>
<p>上小节，简单的使用<code>LoadBalancerClient</code>进行了服务实例获取最后调用，也说了其实<code>LoadBalancerClient</code>是个接口类。而<code>Ribbon</code>实现了此接口，对应实现类为：<code>RibbonLoadBalancerClient</code>.</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/40970081.jpg" alt="40970081.jpg" data-caption="40970081.jpg" loading="lazy"></p>
<h3 id="Ribbon-实例"><a href="#Ribbon-实例" class="headerlink" title="Ribbon 实例"></a>Ribbon 实例</h3><p>现在我们来看下，使用<code>Ribbon</code>的方式如何进行更加优雅的方式进行服务调用。</p>
<p><strong>创建一个工程：**</strong><code>spring-cloud-eureka-consumer-ribbon</code>**<br>(其实这个工程和<code>spring-cloud-eureka-consumer</code>是差不多的，只是有些许不同。)</p>
<p>0.加入 pom 依赖</p>
<pre class="language-text" data-language="text"><code class="language-text">&lt;!-- 客户端依赖 -->
    &lt;dependency>
        &lt;groupId>org.springframework.cloud&lt;/groupId>
        &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId>
    &lt;/dependency>
    &lt;dependency>
        &lt;groupId>org.springframework.boot&lt;/groupId>
        &lt;artifactId>spring-boot-starter-web&lt;/artifactId>
    &lt;/dependency>
</code></pre>

<p>1.配置文件修改，添加注册中心等相关信息。</p>
<pre class="language-text" data-language="text"><code class="language-text">spring.application.name=eureka-consumer-ribbon
server.port=8018

#指定注册中心地址
eureka.client.service-url.defaultZone=http://127.0.0.1:1000/eureka
# 启用ip配置 这样在注册中心列表中看见的是以ip+端口呈现的
eureka.instance.prefer-ip-address=true
# 实例名称  最后呈现地址：ip:2000
eureka.instance.instance-id=$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;
</code></pre>

<p>2.编写启动类，加入<code>@EnableDiscoveryClient</code>，同时申明一个<code>RestTemplate</code>，<strong>这里和原先不同，就在于加入了**</strong><code>@LoadBalanced</code>*<strong>*注解进行修饰**</strong><code>RestTemplate</code>*<strong>*类，稍后会大致讲解下是如何进行实现的。</strong></p>
<pre class="language-text" data-language="text"><code class="language-text">@SpringBootApplication
@EnableDiscoveryClient
@Slf4j
public class EurekaConsumerRibbonApplication &#123;

    public static void main(String[] args) throws Exception &#123;
        SpringApplication.run(EurekaConsumerRibbonApplication.class, args);
        log.info("spring-cloud-eureka-consumer-ribbon启动!");
    &#125;

    //添加 @LoadBalanced 使其具备了使用LoadBalancerClient 进行负载均衡的能力
    @Bean
    @LoadBalanced
    public RestTemplate restTemplage() &#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>

<p>3.编写测试类，进行服务调用。</p>
<pre class="language-text" data-language="text"><code class="language-text">/**
 * ribbon访问客户端示例
 * @author Hehui
 *
 */
@RestController
@Slf4j
public class DemoController &#123;

    @Autowired
    RestTemplate restTemplate;

    @GetMapping("/hello")
    public String hello(String name) &#123;
        //直接使用服务名进行访问
        log.info("请求参数name:&#123;&#125;", name);
        return restTemplate.getForObject("&lt;http://eureka-client/hello?name=>" + name, String.class);
    &#125;
&#125;
</code></pre>

<p>可以看见，可以直接注入<code>RestTemplate</code>，通过服务名直接调用.</p>
<p>4.启动应用，访问:<a target="_blank" rel="noopener" href="http://127.0.0.1:8018/hello?name=oKong">http://127.0.0.1:8018/hello?name=oKong</a> ,可以看见调用成功：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/20652450.jpg" alt="20652450.jpg" data-caption="20652450.jpg" loading="lazy"></p>
<p>控制台输出：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/75877117.jpg" alt="75877117.jpg" data-caption="75877117.jpg" loading="lazy"></p>
<h3 id="简单聊聊-LoadBalanced-注解"><a href="#简单聊聊-LoadBalanced-注解" class="headerlink" title="简单聊聊 LoadBalanced 注解"></a>简单聊聊 LoadBalanced 注解</h3><blockquote>
<p>可以从以上示例中，可以看出，我们就加了一个@LoadBalanced 注解修饰 RestTemplatebean 类，就实现了服务的调用。现在来简单看看具体是如何实现的。</p>
</blockquote>
<p>首先，我们看看此注解的代码说明：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/55952682.jpg" alt="55952682.jpg" data-caption="55952682.jpg" loading="lazy"></p>
<p>从注释可以看出，该注解用来给 RestTemplate 做标记，以使用负载均衡的客户端<code>LoadBalancerClient</code>。</p>
<p>现在来看一眼相同包下的类的情况，可以看到有个<code>LoadBalancerAutoConfiguration</code>,字面意思可以知道这是一个自动配置类，此类就是我们要找的关键类了。</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/33505933.jpg" alt="33505933.jpg" data-caption="33505933.jpg" loading="lazy"></p>
<p><code>LoadBalancerAutoConfiguration</code>,此类不长，一百来行，这里就不贴了。</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/6039671.jpg" alt="6039671.jpg" data-caption="6039671.jpg" loading="lazy"></p>
<p>简单说明下：<br>首先，此类生效的条件是</p>
<pre class="language-text" data-language="text"><code class="language-text">@ConditionalOnClass(RestTemplate.class)
@ConditionalOnBean(LoadBalancerClient.class)
</code></pre>

<ul>
<li><code>RestTemplate</code>类必须存在于当前工程的环境中。</li>
<li>在 Spring 的 Bean 工程中有必须有<code>LoadBalancerClient</code>的实现 Bean。</li>
</ul>
<p>该自动化配置类中，主要做了几件事情：</p>
<ul>
<li>维护了一个被@LoadBalanced 注解修饰的 RestTemplate 对象列表</li>
</ul>
<pre class="language-text" data-language="text"><code class="language-text">@LoadBalanced
    @Autowired(required = false)
    private List&lt;RestTemplate> restTemplates = Collections.emptyList();
</code></pre>

<p>同时为其每个对象通过调用<code>RestTemplateCustomizer</code>添加了一个<code>LoadBalancerInterceptor</code>和<code>RetryLoadBalancerInterceptor</code>拦截器(有生效条件)，其为<code>ClientHttpRequestInterceptor</code>接口的实现类，<code>ClientHttpRequestInterceptor</code>是<code>RestTemplate</code>的请求拦截器</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/75808703.jpg" alt="75808703.jpg" data-caption="75808703.jpg" loading="lazy"></p>
<p><strong>RetryLoadBalancerInterceptor 拦截器</strong></p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/63370995.jpg" alt="63370995.jpg" data-caption="63370995.jpg" loading="lazy"></p>
<p><strong>LoadBalancerInterceptor 拦截器</strong></p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-20/84887976.jpg" alt="84887976.jpg" data-caption="84887976.jpg" loading="lazy"></p>
<p>我们主要看下<code>LoadBalancerInterceptor</code>：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-21/73056978.jpg" alt="73056978.jpg" data-caption="73056978.jpg" loading="lazy"></p>
<p>可以看见，最后是实现了<code>ClientHttpRequestInterceptor</code>接口的实现类执行<code>execute</code>方法进行.</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-21/82979252.jpg" alt="82979252.jpg" data-caption="82979252.jpg" loading="lazy"></p>
<p>从继承关系里，此实现类就是<code>RibbonLoadBalancerClient</code>类了。</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-21/59541189.jpg" alt="59541189.jpg" data-caption="59541189.jpg" loading="lazy"></p>
<pre class="language-text" data-language="text"><code class="language-text">RibbonLoadBalancerClient</code></pre>

<p>类：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-21/13645724.jpg" alt="13645724.jpg" data-caption="13645724.jpg" loading="lazy"></p>
<p>简单来说：最后还是通过<code>loadBalancerClient.choose()</code>获取到服务实例，最通过拼凑 http 地址来进行最后的服务调用。</p>
<p><strong>总体来说，就是通过为加入**</strong><code>@LoadBalanced</code>*<strong>*注解的**</strong><code>RestTemplate</code>*<strong>*添加一个请求拦截器，在请求前通过拦截器获取真正的请求地址，最后进行服务调用。</strong></p>
<p>里面的细节就不阐述了，毕竟源码分析不是很在行呀，大家可以跟踪进去一探究竟吧。</p>
<p><strong>友情提醒：若被**</strong><code>@LoadBalanced</code>*<strong>*注解的**</strong><code>RestTemplate</code>*<strong>*访问正常的服务地址，如**</strong><code>http://127.0.0.1:8080/hello</code>*<strong>*时，是会提示无法找到此服务的。</strong></p>
<p>具体原因：<code>serverid</code>必须是我们访问的<code>服务名称</code> ，当我们直接输入<code>ip</code>的时候获取的<code>server</code>是<code>null</code>，就会抛出异常。</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-21/95656166.jpg" alt="95656166.jpg" data-caption="95656166.jpg" loading="lazy"></p>
<p>此时，<strong>若是需要调用非注册中心的服务，可以创建一个不被**</strong><code>@LoadBalanced</code>*<strong>*注解的**</strong><code>RestTemplate</code>*<strong>*,同时指定 bean 的名称，使用时，使用**</strong><code>@Qualifier</code>*<strong>*指定 name 注入此**</strong><code>RestTemplate</code>*<strong>*。</strong></p>
<pre class="language-text" data-language="text"><code class="language-text">@Bean("normalRestTemplage")
public RestTemplate normalRestTemplage() &#123;
    return new RestTemplate();
&#125;

//使用
@Autowired
@Qualifier("normalRestTemplage")
RestTemplate normalRestTemplate;

 @GetMapping("/ip")
public String ip(String name) &#123;
    //直接使用服务名进行访问
    log.info("使用ip请求，请求参数name:&#123;&#125;", name);
    return normalRestTemplate.getForObject("&lt;http://127.0.0.1:2000/hello?name=>" + name, String.class);
&#125;
</code></pre>

<h3 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h3><p>目前还未进行过自定义负载均衡，这里就简单的举例下，上次整理 ppt 时有讲过一些，但未深入了解过 ⊙﹏⊙‖∣，</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-21/6181280.jpg" alt="6181280.jpg" data-caption="6181280.jpg" loading="lazy"></p>
<p>可以从继承关系看出，是通过继承<code>IRule</code>来实现的。</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-21/39759685.jpg" alt="39759685.jpg" data-caption="39759685.jpg" loading="lazy"></p>
<p><strong>可继承 ClientConfigEnabledRoundRobinRule，来实现自己负载均衡策略。</strong></p>
<h2 id="声明式服务-Feign-实例"><a href="#声明式服务-Feign-实例" class="headerlink" title="声明式服务 Feign 实例"></a>声明式服务 Feign 实例</h2><p>从上一章节，我们知道，当我们要调用一个服务时，需要知道服务名和 api 地址，这样才能进行服务调用，服务少时，这样写觉得没有什么问题，但当服务一多，接口参数很多时，上面的写法就显得不够优雅了。所以，接下来，来说说一种更好更优雅的调用服务的方式：<strong>Feign</strong>。</p>
<blockquote>
<p>Feign 是 Netflix 开发的声明式、模块化的 HTTP 客户端。Feign 可帮助我们更好更快的便捷、优雅地调用 HTTP API。</p>
</blockquote>
<p>在<code>Spring Cloud</code>中，使用<code>Feign</code>非常简单——创建一个接口，并在接口上添加一些注解。<code>Feign</code>支持多种注释，例如 Feign 自带的注解或者 JAX-RS 注解等<br>Spring Cloud 对 Feign 进行了增强，使 Feign 支持了 Spring MVC 注解，并整合了 Ribbon 和 Eureka,从而让 Feign 的使用更加方便。<strong>只需要通过创建接口并用注解来配置它既可完成对 Web 服务接口的绑定。</strong></p>
<h3 id="Feign-实例"><a href="#Feign-实例" class="headerlink" title="Feign 实例"></a>Feign 实例</h3><p><strong>创建个**</strong><code>spring-cloud-eureka-consumer-ribbon</code>*<strong>*工程项目。</strong></p>
<p>0.加入<code>feigin</code>依赖</p>
<pre class="language-text" data-language="text"><code class="language-text">&lt;!-- feign -->
&lt;dependency>
    &lt;groupId>org.springframework.cloud&lt;/groupId>
    &lt;artifactId>spring-cloud-starter-openfeign&lt;/artifactId>
&lt;/dependency>
&lt;!-- eureka客户端依赖 -->
&lt;dependency>
    &lt;groupId>org.springframework.cloud&lt;/groupId>
    &lt;artifactId>spring-cloud-starter-netflix-eureka-client&lt;/artifactId>
&lt;/dependency>
&lt;!-- rest api -->
&lt;dependency>
    &lt;groupId>org.springframework.boot&lt;/groupId>
    &lt;artifactId>spring-boot-starter-web&lt;/artifactId>
&lt;/dependency>
</code></pre>

<p>1.配置文件</p>
<pre class="language-text" data-language="text"><code class="language-text">spring.application.name=eureka-consumer-feign
server.port=8028

#指定注册中心地址
eureka.client.service-url.defaultZone=http://127.0.0.1:1000/eureka
# 启用ip配置 这样在注册中心列表中看见的是以ip+端口呈现的
eureka.instance.prefer-ip-address=true
# 实例名称  最后呈现地址：ip:2000
eureka.instance.instance-id=$&#123;spring.cloud.client.ip-address&#125;:$&#123;server.port&#125;
</code></pre>

<p>2.创建启动类，加入注解<code>@EnableFeignClients</code>，开启<code>feign</code>支持。</p>
<pre class="language-text" data-language="text"><code class="language-text">@SpringBootApplication
@EnableFeignClients
@Slf4j
public class EurekaConsumerFeignApplication &#123;

    public static void main(String[] args) throws Exception &#123;
        SpringApplication.run(EurekaConsumerFeignApplication.class, args);
        log.info("spring-cloud-eureka-consumer-feign启动");
    &#125;

&#125;
</code></pre>

<p>3.创建一个接口类<code>IHelloClient</code>,加入注解<code>@FeignClient</code>来指定这个接口所要调用的服务名称。</p>
<pre class="language-text" data-language="text"><code class="language-text">@FeignClient(name="eureka-client")
public interface IHelloClient &#123;

    /**
     * 定义接口
     * @param name
     * @return
     */
    @RequestMapping(value="/hello", method=RequestMethod.GET)
    public String hello(@RequestParam("name") String name);
&#125;
</code></pre>

<p>4.创建一个 demo 控制层，引入此接口类。</p>
<pre class="language-text" data-language="text"><code class="language-text">/**
 * feign 示例
 * @author Hehui
 *
 */
@RestController
@Slf4j
public class DemoController &#123;

    @Autowired
    IHelloClient helloClient;

    @GetMapping("/hello")
    public String hello(String name) &#123;
        log.info("使用feign调用服务，参数name:&#123;&#125;", name);
        return helloClient.hello(name);
    &#125;
&#125;
</code></pre>

<p>5.启动应用，访问：<a target="_blank" rel="noopener" href="http://127.0.0.1:8028/hello?name=Hehui-feign">http://127.0.0.1:8028/hello?name=Hehui-feign</a></p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-21/99970618.jpg" alt="99970618.jpg" data-caption="99970618.jpg" loading="lazy"></p>
<p><strong>是不是很简单，和调用本地服务是一样的了！</strong></p>
<h3 id="Feign-继承特性"><a href="#Feign-继承特性" class="headerlink" title="Feign 继承特性"></a>Feign 继承特性</h3><blockquote>
<p>Feign 支持继承，但不支持多继承。使用继承，可将一些公共操作分组到一些父类接口中，从而简化 Feign 的开发。</p>
</blockquote>
<p><strong>所以在实际开发中，调用服务接口时，可直接按接口类和实现类进行编写，调用方引入接口依赖，继承一个本地接口，这样接口方法默认都是定义好的，也少了很多编码量。用起来就更爽了，就是有点依赖性，对方服务修改后需要同步更新下，但这个团队内部约定下问题不大的</strong></p>
<p>这里简单实例下，创建一个<code>spring-cloud-eureka-client-api</code>工程。</p>
<p>0.加入依赖，注意此依赖的作用范围：</p>
<pre class="language-text" data-language="text"><code class="language-text">&lt;!--api接口依赖-->
    &lt;dependency>
        &lt;groupId>org.springframework.boot&lt;/groupId>
        &lt;artifactId>spring-boot-starter-web&lt;/artifactId>
        &lt;scope>provided&lt;/scope>
    &lt;/dependency>
</code></pre>

<p>1.编写一个接口类<code>IHellpApi</code>：</p>
<pre class="language-text" data-language="text"><code class="language-text">public interface IHelloApi &#123;
    //定义提供者服务名
    public static final String SERVICE_NAME = "eureka-client";

    /**
     * 定义接口
     * @param name
     * @return
     */
    @RequestMapping(value="/hello", method=RequestMethod.GET)
    public String hello(@RequestParam("name") String name);
&#125;
</code></pre>

<p><strong>修改**</strong><code>spring-cloud-eureka-client</code>*<strong>*工程</strong></p>
<p>0.引入 api 依赖</p>
<pre class="language-text" data-language="text"><code class="language-text">&lt;!-- 导入接口依赖 -->
&lt;dependency>
   &lt;groupId>cn.lqdev.learning&lt;/groupId>
   &lt;artifactId>spring-cloud-eureka-client-api&lt;/artifactId>
   &lt;version>0.0.1-SNAPSHOT&lt;/version>
&lt;/dependency>
</code></pre>

<p>1.创建一个<code>HelloApiImpl</code>类，实现<code>IHelloApi</code>:</p>
<pre class="language-text" data-language="text"><code class="language-text">/**
 * 使用接口方式进行接口编写
 * @author Hehui
 *
 */
@RestController
@Slf4j
public class HelloApiImpl implements IHelloApi &#123;

    @Override
    public String helloApi(@RequestParam("name") String name) &#123;
        log.info("[spring-cloud-eureka-client]服务[helloApi]被调用，参数name值为：&#123;&#125;", name);
        return name + ",helloApi调用!";
    &#125;
&#125;
</code></pre>

<p><strong>此时，**</strong><code>HelloApiImpl</code>*<strong>*是个控制层也是个接口实现类了。</strong></p>
<p><strong>修改**</strong><code>spring-cloud-eureka-consumer-feign</code>*<strong>*工程。</strong> 0.引入 api 依赖</p>
<pre class="language-text" data-language="text"><code class="language-text">&lt;!-- 导入接口依赖 -->
&lt;dependency>
   &lt;groupId>cn.lqdev.learning&lt;/groupId>
   &lt;artifactId>spring-cloud-eureka-client-api&lt;/artifactId>
   &lt;version>0.0.1-SNAPSHOT&lt;/version>
&lt;/dependency>
</code></pre>

<p>1.同样创建一个接口，使其继承<code>IHelloApi</code>:</p>
<pre class="language-text" data-language="text"><code class="language-text">/**
 * 直接继承接口
 * @author Hehui
 *
 */
@FeignClient(name = IHelloApi.SERVICE_NAME)
public interface HelloApi extends IHelloApi&#123;

&#125;
</code></pre>

<p><strong>小技巧：可以在**</strong><code>IHelloApi</code>*<strong>*定义一个服务名变量，如：SERVICE_NAME，这样让提供者进行变量的赋值，可以避免一些不必要的交流成本的，若有变化，服务调用方也无需关心的。一切都是约定编程！</strong></p>
<p>2.修改下<code>DemoController</code>类，注入<code>HelloApi</code>：</p>
<pre class="language-text" data-language="text"><code class="language-text">@Autowired
HelloApi helloApi;

@GetMapping("hello2")
public String hello2(String name) &#123;
    log.info("使用feign继承方式调用服务，参数name:&#123;&#125;", name);
    return helloApi.helloApi(name);
&#125;
</code></pre>

<p>3.分别启动各服务，访问：<a target="_blank" rel="noopener" href="http://127.0.0.1:8028/hello2?name=oKong-api">http://127.0.0.1:8028/hello2?name=oKong-api</a></p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="http://qiniu.xds123.cn/18-9-21/10151632.jpg" alt="10151632.jpg" data-caption="10151632.jpg" loading="lazy"></p>
<p>使用起来没啥差别的，一样的调用，<strong>但对于调用方而言，可以无需去理会具体细节了，照着接口方法去传参就好了。</strong></p>
<p><strong>这种方式，和原来的**</strong><code>dubbo</code>*<strong>*调用的方式是类似的，简单方便。大家可以把接口和实体放入一个包中，调用者和提供者都进行依赖即可。</strong></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在使用<code>Feign</code>时，会碰见一些问题，为了避免不必要的错误，以下这些需要额外注意下。</p>
<ul>
<li>GET 请求多个参数时，需要使用@RequestParam</li>
<li>GET 请求参数为实体时，会自动转换成 POST 请求</li>
<li>POST 请求使用@RequestBody 注解参数</li>
<li>不建议直接将@RequestMapping 注解在类上，直接写在方法上</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/mengdonghui123456/article/details/53981976">https://blog.csdn.net/mengdonghui123456/article/details/53981976</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_spring_cloud_openfeign">https://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_spring_cloud_openfeign</a></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>本章节主要讲解了下服务消费者如何利用原生、ribbon、fegin 三种方式进行服务调用的，其实每种调用方式都是使用 ribbon 来进行调用的，只是有些进行了增强，是的使用起来更简单高效而已。对于其原理的实现，本文未进行详细阐述，大家可以谷歌想相关知识，跟踪下源码了解下，本人也尚未深入研究过，还是停留在使用阶段，之后有时间了看一看，有啥心得再来分享吧。此时若服务上线下线，调用者调用可能会出现短暂的调用异常，最常见的就是找不到服务，此时服务容错保护就排上用场了，所以下一章节，就来说说关于服务容错保护相关知识点~</p>
</blockquote>
<h1 id="LoadBalanced-注解与-RestTemplate"><a href="#LoadBalanced-注解与-RestTemplate" class="headerlink" title="@LoadBalanced 注解与 RestTemplate"></a>@LoadBalanced 注解与 RestTemplate</h1><p>在<code>Spring Cloud</code>微服务应用体系中，远程调用都应负载均衡。我们在使用<code>RestTemplate</code>作为远程调用客户端的时候，开启负载均衡极其简单：<strong>一个**</strong><code>@LoadBalanced</code>*<strong>*注解就搞定了</strong>。<br>相信大家大都使用过<code>Ribbon</code>做<strong>Client 端</strong>的负载均衡，也许你有和我一样的感受：<strong>Ribbon 虽强大但不是特别的好用</strong>。我研究了一番，其实根源还是我们对它内部的原理不够了解，导致对一些现象无法给出合理解释，同时也影响了我们对它的<strong>定制和扩展</strong>。本文就针对此做出梳理，希望大家通过本文也能够对<code>Ribbon</code>有一个较为清晰的理解（本文只解释它<code>@LoadBalanced</code>这一小块内容）。</p>
<p>开启客户端负载均衡只需要一个注解即可，形如这样：</p>
<pre class="language-text" data-language="text"><code class="language-text">@LoadBalanced // 标注此注解后，RestTemplate就具有了客户端负载均衡能力
@Bean
public RestTemplate restTemplate()&#123;
    return new RestTemplate();
&#125;
</code></pre>

<p>说<code>Spring</code>是 Java 界最优秀、最杰出的重复发明轮子作品一点都不为过。本文就代领你一探究竟，为何开启<code>RestTemplate</code>的负载均衡如此简单。</p>
<blockquote>
<p>说明：本文建立在你已经熟练使用 RestTemplate，并且了解 RestTemplate 它相关组件的原理的基础上分析。若对这部分还比较模糊，强行推荐你先参看我前面这篇文章：RestTemplate 的使用和原理你都烂熟于胸了吗？【享学 Spring MVC】</p>
</blockquote>
<h2 id="RibbonAutoConfiguration"><a href="#RibbonAutoConfiguration" class="headerlink" title="RibbonAutoConfiguration"></a>RibbonAutoConfiguration</h2><p>这是<code>Spring Boot/Cloud</code>启动<code>Ribbon</code>的入口自动配置类，需要先有个大概的了解：</p>
<pre class="language-text" data-language="text"><code class="language-text">@Configuration
// 类路径存在com.netflix.client.IClient、RestTemplate等时生效
@Conditional(RibbonAutoConfiguration.RibbonClassesConditions.class)
// // 允许在单个类中使用多个@RibbonClient
@RibbonClients
// 若有Eureka，那就在Eureka配置好后再配置它~~~（如果是别的注册中心呢，ribbon还能玩吗？）
@AutoConfigureAfter(name = "org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration")
@AutoConfigureBefore(&#123; LoadBalancerAutoConfiguration.class, AsyncLoadBalancerAutoConfiguration.class &#125;)
// 加载配置：ribbon.eager-load --> true的话，那么项目启动的时候就会把Client初始化好，避免第一次惩罚
@EnableConfigurationProperties(&#123; RibbonEagerLoadProperties.class, ServerIntrospectorProperties.class &#125;)
public class RibbonAutoConfiguration &#123;

    @Autowired
    private RibbonEagerLoadProperties ribbonEagerLoadProperties;
    // Ribbon的配置文件们~~~~~~~（复杂且重要）
    @Autowired(required = false)
    private List&lt;RibbonClientSpecification> configurations = new ArrayList&lt;>();

    // 特征，FeaturesEndpoint这个端点(`/actuator/features`)会使用它org.springframework.cloud.client.actuator.HasFeatures
    @Bean
    public HasFeatures ribbonFeature() &#123;
        return HasFeatures.namedFeature("Ribbon", Ribbon.class);
    &#125;


    // 它是最为重要的，是一个org.springframework.cloud.context.named.NamedContextFactory  此工厂用于创建命名的Spring容器
    // 这里传入配置文件，每个不同命名空间就会创建一个新的容器（和Feign特别像） 设置当前容器为父容器
    @Bean
    public SpringClientFactory springClientFactory() &#123;
        SpringClientFactory factory = new SpringClientFactory();
        factory.setConfigurations(this.configurations);
        return factory;
    &#125;

    // 这个Bean是关键，若你没定义，就用系统默认提供的Client了~~~
    // 内部使用和持有了SpringClientFactory。。。
    @Bean
    @ConditionalOnMissingBean(LoadBalancerClient.class)
    public LoadBalancerClient loadBalancerClient() &#123;
        return new RibbonLoadBalancerClient(springClientFactory());
    &#125;
    ...
&#125;
</code></pre>

<p>这个配置类最重要的是完成了<code>Ribbon</code>相关组件的自动配置，有了<code>LoadBalancerClient</code>才能做负载均衡（这里使用的是它的唯一实现类<code>RibbonLoadBalancerClient</code>）</p>
<hr>
<h2 id="LoadBalanced"><a href="#LoadBalanced" class="headerlink" title="@LoadBalanced"></a>@LoadBalanced</h2><p>注解本身及其简单（一个属性都木有）：</p>
<pre class="language-text" data-language="text"><code class="language-text">// 所在包是org.springframework.cloud.client.loadbalancer
// 能标注在字段、方法参数、方法上
// JavaDoc上说得很清楚：它只能标注在RestTemplate上才有效
@Target(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Qualifier
public @interface LoadBalanced &#123;
&#125;
</code></pre>

<p>它最大的特点：头上标注有<code>@Qualifier</code>注解，这是它生效的最重要因素之一，本文后半啦我花了大篇幅介绍它的生效时机。<br>关于<code>@LoadBalanced</code>自动生效的配置，我们需要来到这个自动配置类：<code>LoadBalancerAutoConfiguration</code></p>
<h3 id="LoadBalancerAutoConfiguration"><a href="#LoadBalancerAutoConfiguration" class="headerlink" title="LoadBalancerAutoConfiguration"></a>LoadBalancerAutoConfiguration</h3><pre class="language-text" data-language="text"><code class="language-text">// Auto-configuration for Ribbon (client-side load balancing).
// 它的负载均衡技术依赖于的是Ribbon组件~
// 它所在的包是：org.springframework.cloud.client.loadbalancer
@Configuration
@ConditionalOnClass(RestTemplate.class) //可见它只对RestTemplate生效
@ConditionalOnBean(LoadBalancerClient.class) // Spring容器内必须存在这个接口的Bean才会生效（参见：RibbonAutoConfiguration）
@EnableConfigurationProperties(LoadBalancerRetryProperties.class) // retry的配置文件
public class LoadBalancerAutoConfiguration &#123;

    // 拿到容器内所有的标注有@LoadBalanced注解的Bean们
    // 注意：必须标注有@LoadBalanced注解的才行
    @LoadBalanced
    @Autowired(required = false)
    private List&lt;RestTemplate> restTemplates = Collections.emptyList();
    // LoadBalancerRequestTransformer接口：允许使用者把request + ServiceInstance --> 改造一下
    // Spring内部默认是没有提供任何实现类的（匿名的都木有）
    @Autowired(required = false)
    private List&lt;LoadBalancerRequestTransformer> transformers = Collections.emptyList();

    // 配置一个匿名的SmartInitializingSingleton 此接口我们应该是熟悉的
    // 它的afterSingletonsInstantiated()方法会在所有的单例Bean初始化完成之后，再调用一个一个的处理BeanName~
    // 本处：使用配置好的所有的RestTemplateCustomizer定制器们，对所有的`RestTemplate`定制处理
    // RestTemplateCustomizer下面有个lambda的实现。若调用者有需要可以书写然后扔进容器里既生效
    // 这种定制器：若你项目中有多个RestTempalte，需要统一处理的话。写一个定制器是个不错的选择
    // （比如统一要放置一个请求拦截器：输出日志之类的）
    @Bean
    public SmartInitializingSingleton loadBalancedRestTemplateInitializerDeprecated(final ObjectProvider&lt;List&lt;RestTemplateCustomizer>> restTemplateCustomizers) &#123;
        return () -> restTemplateCustomizers.ifAvailable(customizers -> &#123;
            for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) &#123;
                for (RestTemplateCustomizer customizer : customizers) &#123;
                    customizer.customize(restTemplate);
                &#125;
            &#125;
        &#125;);
    &#125;

    // 这个工厂用于createRequest()创建出一个LoadBalancerRequest
    // 这个请求里面是包含LoadBalancerClient以及HttpRequest request的
    @Bean
    @ConditionalOnMissingBean
    public LoadBalancerRequestFactory loadBalancerRequestFactory(LoadBalancerClient loadBalancerClient) &#123;
        return new LoadBalancerRequestFactory(loadBalancerClient, this.transformers);
    &#125;

    // =========到目前为止还和负载均衡没啥关系==========
    // =========接下来的配置才和负载均衡有关（当然上面是基础项）==========

    // 若有Retry的包，就是另外一份配置，和这差不多~~
    @Configuration
    @ConditionalOnMissingClass("org.springframework.retry.support.RetryTemplate")
    static class LoadBalancerInterceptorConfig &#123;、

        // 这个Bean的名称叫`loadBalancerClient`，我个人觉得叫`loadBalancerInterceptor`更合适吧（虽然ribbon是唯一实现）
        // 这里直接使用的是requestFactory和Client构建一个拦截器对象
        // LoadBalancerInterceptor可是`ClientHttpRequestInterceptor`，它会介入到http.client里面去
        // LoadBalancerInterceptor也是实现负载均衡的入口，下面详解
        // Tips:这里可没有@ConditionalOnMissingBean哦~~~~
        @Bean
        public LoadBalancerInterceptor ribbonInterceptor(LoadBalancerClient loadBalancerClient, LoadBalancerRequestFactory requestFactory) &#123;
            return new LoadBalancerInterceptor(loadBalancerClient, requestFactory);
        &#125;


        // 向容器内放入一个RestTemplateCustomizer 定制器
        // 这个定制器的作用上面已经说了：在RestTemplate初始化完成后，应用此定制化器在**所有的实例上**
        // 这个匿名实现的逻辑超级简单：向所有的RestTemplate都塞入一个loadBalancerInterceptor 让其具备有负载均衡的能力

        // Tips：此处有注解@ConditionalOnMissingBean。也就是说如果调用者自己定义过RestTemplateCustomizer类型的Bean，此处是不会执行的
        // 请务必注意这点：容易让你的负载均衡不生效哦~~~~
        @Bean
        @ConditionalOnMissingBean
        public RestTemplateCustomizer restTemplateCustomizer(final LoadBalancerInterceptor loadBalancerInterceptor) &#123;
            return restTemplate -> &#123;
                List&lt;ClientHttpRequestInterceptor> list = new ArrayList&lt;>(restTemplate.getInterceptors());
                list.add(loadBalancerInterceptor);
                restTemplate.setInterceptors(list);
            &#125;;
        &#125;
    &#125;
    ...
&#125;
</code></pre>

<p>这段配置代码稍微有点长，我把流程总结为如下几步：</p>
<ol>
<li><code>LoadBalancerAutoConfiguration</code>要想生效类路径必须有<code>RestTemplate</code>，以及 Spring 容器内必须有<code>LoadBalancerClient</code>的实现 Bean<br>\1. <code>LoadBalancerClient</code>的唯一实现类是：<code>org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient</code></li>
<li><code>LoadBalancerInterceptor</code>是个<code>ClientHttpRequestInterceptor</code>客户端请求拦截器。它的作用是在客户端发起请求之前拦截，<strong>进而实现客户端的负载均衡</strong></li>
<li><code>restTemplateCustomizer()</code>返回的匿名定制器<code>RestTemplateCustomizer</code>它用来给所有的<code>RestTemplate</code>加上负载均衡拦截器（需要注意它的<code>@ConditionalOnMissingBean</code>注解~）</li>
</ol>
<p>不难发现，负载均衡实现的核心就是一个拦截器，就是这个拦截器让一个普通的<code>RestTemplate</code>逆袭成为了一个具有负载均衡功能的请求器</p>
<h3 id="LoadBalancerInterceptor"><a href="#LoadBalancerInterceptor" class="headerlink" title="LoadBalancerInterceptor"></a><code>LoadBalancerInterceptor</code></h3><p>该类唯一被使用的地方就是<code>LoadBalancerAutoConfiguration</code>里配置上去~</p>
<pre class="language-text" data-language="text"><code class="language-text">public class LoadBalancerInterceptor implements ClientHttpRequestInterceptor &#123;

    // 这个命名都不叫Client了，而叫loadBalancer~~~
    private LoadBalancerClient loadBalancer;
    // 用于构建出一个Request
    private LoadBalancerRequestFactory requestFactory;
    ... // 省略构造函数（给这两个属性赋值）

    @Override
    public ClientHttpResponse intercept(final HttpRequest request, final byte[] body, final ClientHttpRequestExecution execution) throws IOException &#123;
        final URI originalUri = request.getURI();
        String serviceName = originalUri.getHost();
        Assert.state(serviceName != null, "Request URI does not contain a valid hostname: " + originalUri);
        return this.loadBalancer.execute(serviceName, this.requestFactory.createRequest(request, body, execution));
    &#125;
&#125;
</code></pre>

<p>此拦截器拦截请求后把它的<code>serviceName</code>委托给了<code>LoadBalancerClient</code>去执行，根据<code>ServiceName</code>可能对应 N 多个实际的<code>Server</code>，因此就可以从众多的 Server 中运用均衡算法，挑选出一个最为合适的<code>Server</code>做最终的请求（它持有真正的请求执行器<code>ClientHttpRequestExecution</code>）。</p>
<hr>
<h3 id="LoadBalancerClient"><a href="#LoadBalancerClient" class="headerlink" title="LoadBalancerClient"></a>LoadBalancerClient</h3><p>请求被拦截后，最终都是委托给了<code>LoadBalancerClient</code>处理。</p>
<pre class="language-text" data-language="text"><code class="language-text">// 由使用负载平衡器选择要向其发送请求的服务器的类实现
public interface ServiceInstanceChooser &#123;

    // 从负载平衡器中为指定的服务选择Service服务实例。
    // 也就是根据调用者传入的serviceId，负载均衡的选择出一个具体的实例出来
    ServiceInstance choose(String serviceId);
&#125;

// 它自己定义了三个方法
public interface LoadBalancerClient extends ServiceInstanceChooser &#123;

    // 执行请求
    &lt;T> T execute(String serviceId, LoadBalancerRequest&lt;T> request) throws IOException;
    &lt;T> T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T> request) throws IOException;

    // 重新构造url：把url中原来写的服务名 换掉 换成实际的
    URI reconstructURI(ServiceInstance instance, URI original);
&#125;
</code></pre>

<p>它只有一个实现类<code>RibbonLoadBalancerClient</code>（<code>ServiceInstanceChooser</code>是有多个实现类的~）。</p>
<h3 id="RibbonLoadBalancerClient"><a href="#RibbonLoadBalancerClient" class="headerlink" title="RibbonLoadBalancerClient"></a><code>RibbonLoadBalancerClient</code></h3><p>首先我们应当关注它的<code>choose()</code>方法：</p>
<pre class="language-text" data-language="text"><code class="language-text">public class RibbonLoadBalancerClient implements LoadBalancerClient &#123;

    @Override
    public ServiceInstance choose(String serviceId) &#123;
        return choose(serviceId, null);
    &#125;
    // hint：你可以理解成分组。若指定了，只会在这个偏好的分组里面去均衡选择
    // 得到一个Server后，使用RibbonServer把server适配起来~~~
    // 这样一个实例就选好了~~~真正请求会落在这个实例上~
    public ServiceInstance choose(String serviceId, Object hint) &#123;
        Server server = getServer(getLoadBalancer(serviceId), hint);
        if (server == null) &#123;
            return null;
        &#125;
        return new RibbonServer(serviceId, server, isSecure(server, serviceId),
                serverIntrospector(serviceId).getMetadata(server));
    &#125;

    // 根据ServiceId去找到一个属于它的负载均衡器
    protected ILoadBalancer getLoadBalancer(String serviceId) &#123;
        return this.clientFactory.getLoadBalancer(serviceId);
    &#125;

&#125;
</code></pre>

<p><code>choose方法</code>：传入 serviceId，然后通过<code>SpringClientFactory</code>获取负载均衡器<code>com.netflix.loadbalancer.ILoadBalancer</code>，最终委托给它的<code>chooseServer()</code>方法选取到一个<code>com.netflix.loadbalancer.Server</code>实例，也就是说真正完成<code>Server</code>选取的是<code>ILoadBalancer</code>。</p>
<blockquote>
<p>ILoadBalancer 以及它相关的类是一个较为庞大的体系，本文不做更多的展开，而是只聚焦在我们的流程上</p>
</blockquote>
<p><code>LoadBalancerInterceptor</code>执行的时候是直接委托执行的<code>loadBalancer.execute()</code>这个方法：</p>
<pre class="language-text" data-language="text"><code class="language-text">RibbonLoadBalancerClient：

    // hint此处传值为null：一视同仁
    // 说明：LoadBalancerRequest是通过LoadBalancerRequestFactory.createRequest(request, body, execution)创建出来的
    // 它实现LoadBalancerRequest接口是用的一个匿名内部类，泛型类型是ClientHttpResponse
    // 因为最终执行的显然还是执行器：ClientHttpRequestExecution.execute()
    @Override
    public &lt;T> T execute(String serviceId, LoadBalancerRequest&lt;T> request) throws IOException &#123;
        return execute(serviceId, request, null);
    &#125;
    // public方法（非接口方法）
    public &lt;T> T execute(String serviceId, LoadBalancerRequest&lt;T> request, Object hint) throws IOException &#123;
        // 同上：拿到负载均衡器，然后拿到一个serverInstance实例
        ILoadBalancer loadBalancer = getLoadBalancer(serviceId);
        Server server = getServer(loadBalancer, hint);
        if (server == null) &#123; // 若没找到就直接抛出异常。这里使用的是IllegalStateException这个异常
            throw new IllegalStateException("No instances available for " + serviceId);
        &#125;

        // 把Server适配为RibbonServer  isSecure：客户端是否安全
        // serverIntrospector内省  参考配置文件：ServerIntrospectorProperties
        RibbonServer ribbonServer = new RibbonServer(serviceId, server,
                isSecure(server, serviceId), serverIntrospector(serviceId).getMetadata(server));

        //调用本类的重载接口方法~~~~~
        return execute(serviceId, ribbonServer, request);
    &#125;

    // 接口方法：它的参数是ServiceInstance --> 已经确定了唯一的Server实例~~~
    @Override
    public &lt;T> T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T> request) throws IOException &#123;

        // 拿到Server）（说白了，RibbonServer是execute时的唯一实现）
        Server server = null;
        if (serviceInstance instanceof RibbonServer) &#123;
            server = ((RibbonServer) serviceInstance).getServer();
        &#125;
        if (server == null) &#123;
            throw new IllegalStateException("No instances available for " + serviceId);
        &#125;

        // 说明：执行的上下文是和serviceId绑定的
        RibbonLoadBalancerContext context = this.clientFactory.getLoadBalancerContext(serviceId);
        ...
        // 真正的向server发送请求，得到返回值
        // 因为有拦截器，所以这里肯定说执行的是InterceptingRequestExecution.execute()方法
        // so会调用ServiceRequestWrapper.getURI()，从而就会调用reconstructURI()方法
            T returnVal = request.apply(serviceInstance);
            return returnVal;
        ... // 异常处理
    &#125;
</code></pre>

<p><code>returnVal</code>是一个<code>ClientHttpResponse</code>，最后交给<code>handleResponse()</code>方法来处理异常情况（若存在的话），若无异常就交给提取器提值：<code>responseExtractor.extractData(response)</code>，这样整个请求就算全部完成了。</p>
<h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><p>针对<code>@LoadBalanced</code>下的<code>RestTemplate</code>的使用，我总结如下细节供以参考：</p>
<ol>
<li>传入的<code>String</code>类型的 url 必须是绝对路径（<code>http://...</code>），否则抛出异常：<code>java.lang.IllegalArgumentException: URI is not absolute</code></li>
<li><code>serviceId</code>不区分大小写（<code>http://user/...效果同http://USER/...</code>）</li>
<li><code>serviceId</code>后请不要跟 port 端口号了~~~</li>
</ol>
<p>最后，需要特别指出的是：标注有<code>@LoadBalanced</code>的<code>RestTemplate</code>只能书写<code>serviceId</code>而不能再写<code>IP地址/域名</code>去发送请求了。若你的项目中两种 case 都有需要，请定义多个<code>RestTemplate</code>分别应对不同的使用场景~</p>
<h3 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h3><p>了解了它的执行流程后，若需要本地测试（不依赖于注册中心），可以这么来做：</p>
<pre class="language-text" data-language="text"><code class="language-text">// 因为自动配置头上有@ConditionalOnMissingBean注解，所以自定义一个覆盖它的行为即可
// 此处复写它的getServer()方法，返回一个固定的（访问百度首页）即可，方便测试
@Bean
public LoadBalancerClient loadBalancerClient(SpringClientFactory factory) &#123;
    return new RibbonLoadBalancerClient(factory) &#123;
        @Override
        protected Server getServer(ILoadBalancer loadBalancer, Object hint) &#123;
            return new Server("www.baidu.com", 80);
        &#125;
    &#125;;
&#125;
</code></pre>

<p>这么一来，下面这个访问结果就是百度首页的 html 内容喽。</p>
<pre class="language-text" data-language="text"><code class="language-text">@Test
public void contextLoads() &#123;
    String obj = restTemplate.getForObject("&lt;http://my-serviceId>", String.class);
    System.out.println(obj);
&#125;
</code></pre>

<blockquote>
<p>此处 my-serviceId 肯定是不存在的，但得益于我上面自定义配置的 LoadBalancerClient</p>
</blockquote>
<p>什么，写死<code>return</code>一个<code>Server</code>实例不优雅？确实，总不能每次上线前还把这部分代码给注释掉吧，若有多个实例呢？还得自己写负载均衡算法吗？很显然<code>Spring Cloud</code>早早就为我们考虑到了这一点：<strong>脱离 Eureka 使用配置 listOfServers 进行客户端负载均衡调度（**</strong><code>&lt;clientName&gt;.&lt;nameSpace&gt;.listOfServers=&lt;comma delimited hostname:port strings&gt;</code>*<strong>*）</strong></p>
<p>对于上例我只需要在主配置文件里这么配置一下：</p>
<pre class="language-text" data-language="text"><code class="language-text"># ribbon.eureka.enabled=false # 若没用euraka，此配置可省略。否则不可以
my-serviceId.ribbon.listOfServers=www.baidu.com # 若有多个实例请用逗号分隔
</code></pre>

<p>效果完全同上。</p>
<blockquote>
<p>Tips：这种配置法不需要是完整的绝对路径，http:&#x2F;&#x2F;是可以省略的（new Server()方式亦可）</p>
</blockquote>
<h3 id="自己添加一个记录请求日志的拦截器可行吗？"><a href="#自己添加一个记录请求日志的拦截器可行吗？" class="headerlink" title="自己添加一个记录请求日志的拦截器可行吗？"></a>自己添加一个记录请求日志的拦截器可行吗？</h3><p>显然是可行的，我给出示例如下：</p>
<pre class="language-text" data-language="text"><code class="language-text">@LoadBalanced
@Bean
public RestTemplate restTemplate() &#123;
    RestTemplate restTemplate = new RestTemplate();
    List&lt;ClientHttpRequestInterceptor> list = new ArrayList&lt;>();
    list.add((request, body, execution) -> &#123;
        System.out.println("当前请求的URL是：" + request.getURI().toString());
        return execution.execute(request, body);
    &#125;);
    restTemplate.setInterceptors(list);
    return restTemplate;
&#125;
</code></pre>

<p>这样每次客户端的请求都会打印这句话：<code>当前请求的URI是：&lt;http://my-serviceId</code>&gt;，一般情况（缺省情况）自定义的拦截器都会在负载均衡拦截器前面执行（因为它要执行最终的请求）。若你有必要定义多个拦截器且要控制顺序，可通过<code>Ordered</code>系列接口来实现~</p>
<hr>
<p><strong>最后的最后，我抛出一个非常非常重要的问题：</strong></p>
<pre class="language-text" data-language="text"><code class="language-text">@LoadBalanced
@Autowired(required = false)
private List&lt;RestTemplate> restTemplates = Collections.emptyList();
</code></pre>

<p><code>@Autowired</code> + <code>@LoadBalanced</code>能把你配置的<code>RestTemplate</code>自动注入进来拿来定制呢？？？核心原理是什么？</p>
<h2 id="提示：本原理内容属于Spring-Framwork核心技术，建议深入思考而不囫囵吞枣。有疑问的可以给我留言，我也将会在下篇文章给出详细解答（建议先思考）"><a href="#提示：本原理内容属于Spring-Framwork核心技术，建议深入思考而不囫囵吞枣。有疑问的可以给我留言，我也将会在下篇文章给出详细解答（建议先思考）" class="headerlink" title="&gt; 提示：本原理内容属于Spring Framwork核心技术，建议深入思考而不囫囵吞枣。有疑问的可以给我留言，我也将会在下篇文章给出详细解答（建议先思考）"></a>&gt; 提示：本原理内容属于<code>Spring Framwork</code>核心技术，建议深入思考而不囫囵吞枣。有疑问的可以给我留言，我也将会在下篇文章给出详细解答（建议先思考）</h2><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a target="_blank" rel="noopener" href="https://fangshixiang.blog.csdn.net/article/details/100753981">RestTemplate 的使用和原理你都烂熟于胸了吗？【享学 Spring MVC】</a><a target="_blank" rel="noopener" href="https://fangshixiang.blog.csdn.net/article/details/100890879">@Qualifier 高级应用—按类别批量依赖注入【享学 Spring】</a></p>
<p>-—————————————————–</p>
<h1 id="Ribbon-是如何通过一个-LoadBalanced-注解就实现负载均衡的"><a href="#Ribbon-是如何通过一个-LoadBalanced-注解就实现负载均衡的" class="headerlink" title="Ribbon 是如何通过一个@LoadBalanced 注解就实现负载均衡的"></a>Ribbon 是如何通过一个@LoadBalanced 注解就实现负载均衡的</h1><p>原创<a target="_blank" rel="noopener" href="https://me.csdn.net/weixin_38106322">绅士 jiejie</a> 最后发布于 2019-11-08 15:09:04 阅读数 94 收藏</p>
<p>发布于 2019-11-06 16:14:45</p>
<p>分类专栏： <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38106322/category_9431347.html">Spring Cloud</a></p>
<p>版权声明：本文为博主原创文章，遵循<a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。</p>
<p>本文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38106322/article/details/102937313">https://blog.csdn.net/weixin_38106322&#x2F;article&#x2F;details&#x2F;102937313</a></p>
<p>展开</p>
<p>一.介绍下测试用到的服务</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://img-blog.csdnimg.cn/20191106161350811.png" alt="20191106161350811.png" data-caption="20191106161350811.png" loading="lazy"></p>
<p>从 Eureka 注册中心中可以可以看出有 EUREKA-CLIENT 和 RIBBON-CLIENT 的服务，其中 EUREKA-CLIENT 有两个节点作为服务提供者，而 RIBBON-CLIENT 则是服务消费者，通过 RestTemplate 来消费 EUREKA-CLIENT 的服务。</p>
<p>下面代码就是简单实现 Ribbon 负载均衡的配置类：</p>
<pre class="language-text" data-language="text"><code class="language-text">@Configuration
public class RibbonConfig &#123;

    @Bean
    @LoadBalanced
    RestTemplate getRestTemlate() &#123;
        return new RestTemplate();
    &#125;
&#125;
</code></pre>

<p>这样简单的通过一个@LoadBalanced 注解在 RestTemplate 上 ，在 RestTemplate 远程调用的时候，就会出现负载均衡的效果。</p>
<p>二.一步一步理清 Ribbon 负载均衡的逻辑</p>
<ol>
<li>首先全局搜索@LoadBalanced 这个注解，发现在 LoadBalancerAutoConfiguration 类有用到该注解：</li>
</ol>
<pre class="language-text" data-language="text"><code class="language-text">@Configuration
@ConditionalOnClass(RestTemplate.class)
@ConditionalOnBean(LoadBalancerClient.class)
@EnableConfigurationProperties(LoadBalancerRetryProperties.class)
public class LoadBalancerAutoConfiguration &#123;

    /**
    *  这段代码的作用是将有用@LoadBalanced注解的RestTemplate注入
    */
	@LoadBalanced
	@Autowired(required = false)
	private List&lt;RestTemplate> restTemplates = Collections.emptyList();
&#125;
</code></pre>

<p>分析以上代码：</p>
<ul>
<li>通过@Configuration 表明这是一个配置类</li>
<li>通过@ConditionalOnClass(RestTemplate.class)可以知道 RestTemplate 类要在类路径上存在才会实例化 LoadBalancerAutoConfiguration</li>
<li>通过@ConditionalOnBean(LoadBalancerClient.class)可以知道 LoadBalancerClient 类要存在才会实例化 LoadBalancerAutoConfiguration</li>
<li>@EnableConfigurationProperties(LoadBalancerRetryProperties.class)是用来使用@ConfigurationProperties 注解的类 LoadBalancerRetryProperties 生效，贴上部分 LoadBalancerRetryProperties 类的代码，会更清晰：</li>
</ul>
<pre class="language-text" data-language="text"><code class="language-text">@ConfigurationProperties("spring.cloud.loadbalancer.retry")
public class LoadBalancerRetryProperties &#123;

	private boolean enabled = true;

	/**
	 * Returns true if the load balancer should retry failed requests.
	 * @return True if the load balancer should retry failed requests; false otherwise.
	 */
	public boolean isEnabled() &#123;
		return this.enabled;
	&#125;
</code></pre>

<ol>
<li>所以重启下 RIBBON-CLIENT 服务，Debug 继续看 LoadBalancerAutoConfiguration 类的代码，发现在启动时会先进入 LoadBalancerAutoConfiguration 的 loadBalancerRequestFactory 方法，实例化出 LoadBalancerRequestFactory</li>
</ol>
<pre class="language-text" data-language="text"><code class="language-text">   @Bean
@ConditionalOnMissingBean
public LoadBalancerRequestFactory loadBalancerRequestFactory(
		LoadBalancerClient loadBalancerClient) &#123;
	return new LoadBalancerRequestFactory(loadBalancerClient, this.transformers);
&#125;
</code></pre>

<p>接下去断点进入 LoadBalancerAutoConfiguration 类中的静态内部类 LoadBalancerInterceptorConfig 的 ribbonInterceptor 方法，可以看出这是为了实例化出 LoadBalancerInterceptor 拦截器</p>
<pre class="language-text" data-language="text"><code class="language-text">   @Configuration
@ConditionalOnMissingClass("org.springframework.retry.support.RetryTemplate")
static class LoadBalancerInterceptorConfig &#123;

	@Bean
	public LoadBalancerInterceptor ribbonInterceptor(
			LoadBalancerClient loadBalancerClient,
			LoadBalancerRequestFactory requestFactory) &#123;
		return new LoadBalancerInterceptor(loadBalancerClient, requestFactory);
	&#125;
</code></pre>

<p>继续跟断点，进入了 loadBalancedRestTemplateInitializerDeprecated 方法，可以看出这个方法里主要的逻辑代码是 customizer.customize(restTemplate)</p>
<pre class="language-text" data-language="text"><code class="language-text">   @Bean
public SmartInitializingSingleton loadBalancedRestTemplateInitializerDeprecated(
		final ObjectProvider&lt;List&lt;RestTemplateCustomizer>> restTemplateCustomizers) &#123;
	return () -> restTemplateCustomizers.ifAvailable(customizers -> &#123;
		for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) &#123;
			for (RestTemplateCustomizer customizer : customizers) &#123;
				customizer.customize(restTemplate);
			&#125;
		&#125;
	&#125;);
&#125;
</code></pre>

<p>继续 Debug,断点进入 LoadBalancerAutoConfiguration 类中的静态内部类 LoadBalancerInterceptorConfig：</p>
<pre class="language-text" data-language="text"><code class="language-text">@Configuration
@ConditionalOnMissingClass("org.springframework.retry.support.RetryTemplate")
	static class LoadBalancerInterceptorConfig &#123;
		@Bean
		@ConditionalOnMissingBean
		public RestTemplateCustomizer restTemplateCustomizer(
				final LoadBalancerInterceptor loadBalancerInterceptor) &#123;
			return restTemplate -> &#123;
				List&lt;ClientHttpRequestInterceptor> list = new ArrayList&lt;>(
						restTemplate.getInterceptors());
				list.add(loadBalancerInterceptor);
				restTemplate.setInterceptors(list);
			&#125;;
		&#125;
	&#125;
</code></pre>

<p>通过 list.add(loadBalancerInterceptor)和 restTemplate.setInterceptors(list)两段代码可以看出，这是要给 restTemplate 加上 loadBalancerInterceptor 拦截器。</p>
<p>那么接下来看看 loadBalancerInterceptor 拦截器里做了什么,通过页面发起一个 http 请求,断点进入到 LoadBalancerInterceptor 类的 intercept 方法，</p>
<pre class="language-text" data-language="text"><code class="language-text">@Override
	public ClientHttpResponse intercept(final HttpRequest request, final byte[] body,
			final ClientHttpRequestExecution execution) throws IOException &#123;
		final URI originalUri = request.getURI();
		String serviceName = originalUri.getHost();
		Assert.state(serviceName != null,
				"Request URI does not contain a valid hostname: " + originalUri);
		return this.loadBalancer.execute(serviceName,
				this.requestFactory.createRequest(request, body, execution));
	&#125;
</code></pre>

<p>截图看下信息：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://img-blog.csdnimg.cn/20191107162815756.png" alt="20191107162815756.png" data-caption="20191107162815756.png" loading="lazy"></p>
<p>可以看到该方法取得了 request 里的 url 和 servicName，然后将这些参数交给 loadBalancer.execute 去执行方法。而 loadBalancer 是 LoadBalancerClient 类的实例。<br>看下 LoadBalancerClient 的类图，可以看到 LoadBalancerClient 继承了 ServiceInstanceChooser，LoadBalancerClient 的实现类是 RibbonLoadBalancerClient</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://img-blog.csdnimg.cn/20191107163802485.png" alt="20191107163802485.png" data-caption="20191107163802485.png" loading="lazy"></p>
<p>逻辑继续，断点进入了 RibbonLoadBalancerClient 的 execute 方法</p>
<pre class="language-text" data-language="text"><code class="language-text">public &lt;T> T execute(String serviceId, LoadBalancerRequest&lt;T> request, Object hint)
			throws IOException &#123;
		ILoadBalancer loadBalancer = getLoadBalancer(serviceId);
		Server server = getServer(loadBalancer, hint);
		if (server == null) &#123;
			throw new IllegalStateException("No instances available for " + serviceId);
		&#125;
		RibbonServer ribbonServer = new RibbonServer(serviceId, server,
				isSecure(server, serviceId),
				serverIntrospector(serviceId).getMetadata(server));

		return execute(serviceId, ribbonServer, request);
	&#125;
</code></pre>

<p>跟着断点一步一步看方法：</p>
<ul>
<li>ILoadBalancer loadBalancer &#x3D; getLoadBalancer(serviceId);</li>
</ul>
<p>经过这个方法，得到 loadBalancer，从截图里可以看到，loadBalancer 里有个 allServerList 集合，里面有两个对象，端口号分别是 8763 和 8762，这就是我们提供的服务节点。</p>
<pre><code>![20191107172116799.png](https://img-blog.csdnimg.cn/20191107172116799.png)
</code></pre>
<ul>
<li>Server server &#x3D; getServer(loadBalancer, hint)</li>
</ul>
<p>从图里可以看出，通过这个 getServer 方法，会返回给我们一个当前可调用的服务节点，而至于怎么返回服务节点，会再写一篇分析，写完后会更新链接到该篇。</p>
<pre><code>![20191107172537248.png](https://img-blog.csdnimg.cn/20191107172537248.png)
</code></pre>
<ul>
<li>生成 RibbonServer 作为参数传入 execute 方法</li>
<li>运行 execute 方法</li>
</ul>
<p>接着跟进 execute 方法</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://img-blog.csdnimg.cn/20191108111558612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwNjMyMg==,size_16,color_FFFFFF,t_70" alt="20191108111558612.png" data-caption="20191108111558612.png" loading="lazy"></p>
<p>可以看该方法里的关键执行方法是：<br>T returnVal &#x3D; request.apply(serviceInstance);<br>接着看 apply 方法，发现它是 LoadBalancerRequest 接口的方法，该接口却没有具体的实现类：</p>
<pre class="language-text" data-language="text"><code class="language-text">public interface LoadBalancerRequest&lt;T> &#123;

	T apply(ServiceInstance instance) throws Exception;

&#125;
</code></pre>

<p>思路回溯，是 request 对象调用的 apply 方法，而 request 其实是 execute 方法传进来的参数，追溯到源头，发现是 LoadBalancerInterceptor 类的 intercept 方法里 this.requestFactory.createRequest(request, body, execution)生成了 LoadBalancerRequest，然后作为参数传入，之后再调用了 apply 方法</p>
<pre class="language-text" data-language="text"><code class="language-text">@Override
	public ClientHttpResponse intercept(final HttpRequest request, final byte[] body,
			final ClientHttpRequestExecution execution) throws IOException &#123;
		final URI originalUri = request.getURI();
		String serviceName = originalUri.getHost();
		Assert.state(serviceName != null,
				"Request URI does not contain a valid hostname: " + originalUri);
		return this.loadBalancer.execute(serviceName,
				this.requestFactory.createRequest(request, body, execution));
	&#125;
</code></pre>

<p>跟进 createRequest 方法里：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://img-blog.csdnimg.cn/20191108143112594.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwNjMyMg==,size_16,color_FFFFFF,t_70" alt="20191108143112594.png" data-caption="20191108143112594.png" loading="lazy"></p>
<p>可以从图中看到，经过一些操作后，生成的 serviceRequest 对象里的 serviceId 是 eureka-client，也就是我们的服务节点名，而 server 是 localhost:8763，这是具体的服务节点 ip，之后作为参数调用 org.springframework.http.client 包下的 InterceptingClientHttpRequest 类中的 execute 方法断点进入该方法：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://img-blog.csdnimg.cn/20191108145133749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODEwNjMyMg==,size_16,color_FFFFFF,t_70" alt="20191108145133749.png" data-caption="20191108145133749.png" loading="lazy"></p>
<p>可以看出通过 requestFactory.createRequest(request.getURI(), method)方法生成了 ClientHttpRequest 类的实例 delegate，它的 url 就是我们最后真正要请求的，最后正常调用 delegate.execute()方法取得返回 ClientHttpResponse 就好了。</p>
<p>而这里产生了一个疑问，url 是怎么产生的？重新发起请求断点试下<br>发现关键在 LoadBalancerRequestFactory 类中的 createRequest 方法中的这句：</p>
<pre class="language-text" data-language="text"><code class="language-text">HttpRequest serviceRequest = new ServiceRequestWrapper(request, instance,his.loadBalancer);
</code></pre>

<p>跟进 ServiceRequestWrapper 类中，发现它继承了 HttpRequestWrapper 类，同时重写了 getURI 方法</p>
<pre class="language-text" data-language="text"><code class="language-text">public class ServiceRequestWrapper extends HttpRequestWrapper &#123;

	private final ServiceInstance instance;

	private final LoadBalancerClient loadBalancer;

	public ServiceRequestWrapper(HttpRequest request, ServiceInstance instance,
			LoadBalancerClient loadBalancer) &#123;
		super(request);
		this.instance = instance;
		this.loadBalancer = loadBalancer;
	&#125;

	@Override
	public URI getURI() &#123;
		URI uri = this.loadBalancer.reconstructURI(this.instance, getRequest().getURI());
		return uri;
	&#125;

&#125;
</code></pre>

<p>断点打在 getURI 方法里：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://img-blog.csdnimg.cn/201911081504477.png" alt="201911081504477.png" data-caption="201911081504477.png" loading="lazy"></p>
<p>可以看到该方法返回了我们最后需要的 url。</p>
<p>最后，关于 Ribbon 是如何通过一个@LoadBalanced 注解就实现负载均衡的分析就到这了，还是有很多疏漏的地方，但是大致的逻辑就是这样的了，还有一些更深层的比如如何根据策略选出当前提供服务的节点等，留待后续补充，来日方长~</p>

    ｜
  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>Honesty<br>
        <strong>本文链接：</strong><a href="https://docs.hehouhui.cn/archives/20.html" title="https:&#x2F;&#x2F;docs.hehouhui.cn&#x2F;archives&#x2F;20.html" target="_blank" rel="noopener">https:&#x2F;&#x2F;docs.hehouhui.cn&#x2F;archives&#x2F;20.html</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可

        
    </div>


  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
   
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/Redis/" rel="tag">Redis</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/Spring/" rel="tag">Spring</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" rel="tag">分布式</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a>
    
</div>
  
  
    <script async src="/js/copy-codeblock.js?v=1699545727401"></script>
  

  
      <div class="nexmoe-post-footer">
          <script src="https://giscus.app/client.js"
       data-repo="listener-He/NotionNext"
       data-repo-id="R_kgDOJI1XUA"
       data-category="General"
       data-category-id="R_kgDOJOsY1g"
       data-mapping="pathname"
       data-strict="0"
       data-reactions-enabled="1"
       data-emit-metadata="0"
       data-input-position="top"
       data-theme="preferred_color_scheme"
       data-lang="zh-CN"
       data-loading="lazy"
       crossorigin="anonymous"
       async>
 </script>

      </div>
  
</div></div><div class="nexmoe-post-right">    <div class="nexmoe-fixed">
        <div class="nexmoe-tool">

            

            
            
            <button class="mdui-fab catalog" style="overflow:unset;">
                <i class="nexmoefont icon-i-catalog"></i>
                <div class="nexmoe-toc">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RestTemplate"><span class="toc-number">1.</span> <span class="toc-text">RestTemplate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.0.1.</span> <span class="toc-text">何为负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.2.</span> <span class="toc-text">实现的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.0.3.</span> <span class="toc-text">客户端和服务端的负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RestTemplate-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.0.4.</span> <span class="toc-text">RestTemplate 简单介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exchange"><span class="toc-number">1.0.5.</span> <span class="toc-text">exchange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E8%AF%B7%E6%B1%82"><span class="toc-number">1.0.6.</span> <span class="toc-text">GET 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POST-%E8%AF%B7%E6%B1%82"><span class="toc-number">1.0.7.</span> <span class="toc-text">POST 请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LoadBalancerClient-%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">LoadBalancerClient 实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-Ribbon-%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.</span> <span class="toc-text">客户端负载均衡 Ribbon 实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Ribbon-%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">Ribbon 实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A-LoadBalanced-%E6%B3%A8%E8%A7%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">简单聊聊 LoadBalanced 注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">负载均衡器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E6%9C%8D%E5%8A%A1-Feign-%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">声明式服务 Feign 实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Feign-%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">Feign 实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Feign-%E7%BB%A7%E6%89%BF%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.2.</span> <span class="toc-text">Feign 继承特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.3.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.4.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LoadBalanced-%E6%B3%A8%E8%A7%A3%E4%B8%8E-RestTemplate"><span class="toc-number">2.</span> <span class="toc-text">@LoadBalanced 注解与 RestTemplate</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RibbonAutoConfiguration"><span class="toc-number">2.1.</span> <span class="toc-text">RibbonAutoConfiguration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LoadBalanced"><span class="toc-number">2.2.</span> <span class="toc-text">@LoadBalanced</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadBalancerAutoConfiguration"><span class="toc-number">2.2.1.</span> <span class="toc-text">LoadBalancerAutoConfiguration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadBalancerInterceptor"><span class="toc-number">2.2.2.</span> <span class="toc-text">LoadBalancerInterceptor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoadBalancerClient"><span class="toc-number">2.2.3.</span> <span class="toc-text">LoadBalancerClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RibbonLoadBalancerClient"><span class="toc-number">2.2.4.</span> <span class="toc-text">RibbonLoadBalancerClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">2.2.5.</span> <span class="toc-text">使用细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.6.</span> <span class="toc-text">本地测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%AE%B0%E5%BD%95%E8%AF%B7%E6%B1%82%E6%97%A5%E5%BF%97%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E5%8F%AF%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">2.2.7.</span> <span class="toc-text">自己添加一个记录请求日志的拦截器可行吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA%EF%BC%9A%E6%9C%AC%E5%8E%9F%E7%90%86%E5%86%85%E5%AE%B9%E5%B1%9E%E4%BA%8ESpring-Framwork%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%BB%BA%E8%AE%AE%E6%B7%B1%E5%85%A5%E6%80%9D%E8%80%83%E8%80%8C%E4%B8%8D%E5%9B%AB%E5%9B%B5%E5%90%9E%E6%9E%A3%E3%80%82%E6%9C%89%E7%96%91%E9%97%AE%E7%9A%84%E5%8F%AF%E4%BB%A5%E7%BB%99%E6%88%91%E7%95%99%E8%A8%80%EF%BC%8C%E6%88%91%E4%B9%9F%E5%B0%86%E4%BC%9A%E5%9C%A8%E4%B8%8B%E7%AF%87%E6%96%87%E7%AB%A0%E7%BB%99%E5%87%BA%E8%AF%A6%E7%BB%86%E8%A7%A3%E7%AD%94%EF%BC%88%E5%BB%BA%E8%AE%AE%E5%85%88%E6%80%9D%E8%80%83%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">&gt; 提示：本原理内容属于Spring Framwork核心技术，建议深入思考而不囫囵吞枣。有疑问的可以给我留言，我也将会在下篇文章给出详细解答（建议先思考）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB"><span class="toc-number">2.3.1.</span> <span class="toc-text">推荐阅读</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ribbon-%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA-LoadBalanced-%E6%B3%A8%E8%A7%A3%E5%B0%B1%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text">Ribbon 是如何通过一个@LoadBalanced 注解就实现负载均衡的</span></a></li></ol>
                </div>
            </button>
            

            

            <a href="#nexmoe-content" class="backtop toc-link" aria-label="Back To Top" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
        </div>
    </div>
</div></div><div id="nexmoe-footer"><!--!--></div><div><div id="nexmoe-search-space">
	<div class="search-container">
		<div class="search-header">
			<div class="search-input-container">
				<input
					class="search-input"
					type="text"
					placeholder="搜索"
					oninput="sinput();"
				/>
			</div>
			<a class="search-close" onclick="sclose();">×</a>
		</div>
		<div class="search-body"></div>
	</div>
</div>
</div><div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1623991949842711" crossorigin="anonymous"></script>
</div></body></html>